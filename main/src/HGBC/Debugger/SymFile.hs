{-# LANGUAGE BangPatterns #-}
{-# LANGUAGE OverloadedStrings #-}

module HGBC.Debugger.SymFile
  ( parse,
    generate,
  )
where

import qualified Data.Attoparsec.ByteString.Char8 as P
import Data.Bifunctor
import qualified Data.ByteString.Builder as BB
import qualified Data.ByteString.Char8 as BC
import qualified Data.ByteString.Lazy.Char8 as LBC
import Data.Char
import Data.List
import Data.String
import qualified Data.Text as T
import qualified Data.Text.Encoding as T
import qualified Data.Text.Encoding.Error as T
import Data.Word
import Machine.GBC.Disassembler
import Machine.GBC.Util (formatHex)
import Prelude hiding (lines)

data Section = LabelsSection | UnknownSection deriving (Eq, Ord, Show)

-- | Parse a .sym file.
parse :: LBC.ByteString -> [Either String (LongAddress, T.Text)]
parse inString =
  snd
    . foldl' parseLine (LabelsSection, [])
    . filter (not . isComment . snd)
    $ [(1 :: Int) ..]
      `zip` (LBC.toStrict <$> LBC.split '\n' inString)
  where
    parseLine (section, !acc) (lineNo, line) = case P.parseOnly parseHeader line of
      Right section' -> (section', acc)
      Left _ -> case section of
        LabelsSection ->
          ( LabelsSection,
            first (("On line " ++ show lineNo ++ ": ") ++) (P.parseOnly parseLabel line) : acc
          )
        UnknownSection -> (UnknownSection, acc)

    isComment line = case BC.uncons (BC.dropWhile isSpace line) of
      Nothing -> True
      Just (c, _) -> c == ';'
    trim = BC.takeWhile (not . isSpace) . BC.dropWhile isSpace
    decodeSection section = if trim section == "labels" then LabelsSection else UnknownSection
    parseHeader =
      P.skipWhile isSpace
        *> "["
        *> (decodeSection <$> P.takeWhile (/= ']'))
        <* "]"
        <* P.skipWhile isSpace
    parseLabel = do
      P.skipWhile isSpace
      address <- LongAddress <$> P.hexadecimal <*> (":" *> P.hexadecimal)
      P.skipWhile isSpace
      label <- P.takeWhile (not . isSpace)
      P.skipWhile isSpace
      let withoutPrefix = BC.dropWhile (/= '@') label
      pure
        ( if BC.null withoutPrefix
            then (address, T.decodeUtf8With T.lenientDecode label)
            else (address, T.decodeUtf8With T.lenientDecode (BC.cons '.' (BC.drop 1 withoutPrefix)))
        )

-- | Generate a .sym file from a list of labels.
generate :: [(LongAddress, T.Text)] -> LBC.ByteString
generate labels =
  BB.toLazyByteString $
    "; Symbol file regenerated by HGBC\n\n"
      <> (snd . foldl' generateLine ("", "") $ sortOn (encodeAddress . fst) labels)
  where
    isGlobal label = case T.uncons label of
      Nothing -> False
      Just (c, _) -> isAlphaNum c
    generateLine (prefix, acc) (LongAddress bank offset, label) =
      let labelOut = T.encodeUtf8 label
       in ( if isGlobal label then labelOut else prefix,
            acc
              <> fromString
                (if bank <= 0xFF then formatHex (fromIntegral bank :: Word8) else formatHex bank)
              <> ":"
              <> fromString (formatHex offset)
              <> " "
              <> BB.byteString
                ( if isGlobal label
                    then labelOut
                    else prefix <> "@" <> BC.dropWhile (not . isAlphaNum) labelOut
                )
              <> "\n"
          )
